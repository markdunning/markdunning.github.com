---
title: "Introduction to RNA-Seq - Part 3"
author: Mark Dunning
date: 2025-10-30
theme: darkly
image: "/files/training/bulk_rnaseq/treeplot.png"
description: "Further exploration of differential expression, followed by identification of biological pathways of interest"
---

```{r}
#| echo: false
#| message: false
#| warning: false

knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE
)

```


## Quick Start

This section follows on from [Part 1](/training/bulk-rnaseq_1/index.html) and [Part 2](/training/bulk-rnaseq_2/index.html) where we saw how to import raw RNA-seq counts into `DESeq2`, perform some quality assessment and then differential expression. Several packages are required, which can be downloaded with this code:-

```{r eval=FALSE}
source("https://raw.githubusercontent.com/markdunning/markdunning.github.com/refs/heads/master/files/training/bulk_rnaseq/install_bioc_packages.R")
```

The following will also assume you have created a `DESeq2` object in a folder called `Robjects` in your working directory. This can be downloaded with the following.

```{r eval=FALSE}
dir.create("Robjects/",showWarnings = FALSE)
download.file("https://github.com/markdunning/markdunning.github.com/raw/refs/heads/master/files/training/bulk_rnaseq/dds.rds",destfile = "Robjects/dds.rds")
```

# Differential expression with `DESeq2`

```{r echo=FALSE}
dds <- readRDS("Robjects/dds.rds")
```

In [Part 2](/training/bulk-rnaseq_2/index.html) we dissected the `DESeq` workflow for differential expression in some detail. We also created a data frame for "annotating" the results with biological identifiers that are more recognisable.

```{r load-anno, message=FALSE, warning=FALSE}
library(org.Hs.eg.db)
anno <- AnnotationDbi::select(org.Hs.eg.db,keys=rownames(dds),
              columns=c("SYMBOL","GENENAME", "ENTREZID"),
              keytype="ENSEMBL")
# Have a look at the annotation
head(anno)
```

The code to perform differential expression and incorporate the annotations is given below.

```{r results-recap, message=FALSE, warning=FALSE}
library(DESeq2)
library(dplyr)
library(ggplot2)

de_condition <- DESeq(dds)

results_annotated <- results(de_condition, 
        contrast = c("condition", "TGF", "CTR"),
        tidy = TRUE) %>% 
  left_join(anno, by = c("row" = "ENSEMBL")) %>% 
  filter(!duplicated(row)) %>% 
  arrange(padj) %>% 
  ## removing the lfcSE column
  dplyr::select(-lfcSE)

results_annotated %>% 
  slice_head(n = 10)
```

# Filtering the differential expression results

The `results_annotated` tibble contains results for *all* the genes that appeared in our counts data, which could be many 10,000s of potential candidates for being biologically meaningful. Deciding which genes to take forward for further investigation can be quite subtle, and can depend on what your question of interest is. With the simplest criteria applied (e.g. an adjusted p-value of 0.05) you can still be faced with 1000s of genes to interpret. Of course, there are methods for identifying biological themes (see later).

The `padj` and `log2FoldChange` in the results table are common quantities for filtering representing the statistical certainty and effect size respectively. In an ideal world, genes of interest should have a high degree of statistical certainty (extremely low p-value) and large effect size. As correcting for multiple testing is a standard procedure for large datasets, and is included in `DESqe2`as standard, we can be reasonably confident about the p-value adjustments that `DESeq2` performed. We will discuss the `log2FoldChange` later.

At the moment we have almost 5,000 genes with an arbitrary `0.05` cutoff, but not all of them are going to be relevant to our question.

```{r}
dplyr::count(results_annotated, padj <0.05)
```

But wait, we also have some `NA` values. What's the deal with those? Maybe `DESeq2` is doing something non-standard in p-value correction after all.

## Why are some adjusted p-values "`NA`"?

It turns out that `DESeq2` has already done some processing on the results to exclude genes with low expression level across the dataset that it deems to be unreliable and unlikely to be differential-expressed. The genes it filters out (those that have `NA` adjusted p-value) tend to have a lower value of `baseMean`.

```{r filter_vs_baseMean}
results_annotated %>% 
  ggplot(aes(x = is.na(padj), y = baseMean)) + geom_boxplot() + scale_y_log10()
```

The core principle is that genes with very low expression (low average normalized counts) have little power to be called differentially expressed, even if their true $\log_2$ fold change is comparatively large. By testing all genes, you incur a multiple testing penalty for these low-power genes, which reduces the number of genes that can be called significant overall.

The procedure first uses the mean of normalized counts (`baseMean`) across all samples as a filtering mechanism. Genes with very low expression have high $p$-values due to low statistical power (high variance relative to the mean), regardless of their true fold change. `DESeq2` determines an optimal cutoff for the `baseMean` that maximizes the number of genes called significant (`padj` \< $\alpha$, where $\alpha$ is usually $0.1$ or $0.05$). This is done by testing a range of cutoffs and picking the one that yields the largest number of discoveries. Genes with mean counts below this optimal cutoff are removed (in practice their `padj` is set to `NA`). The remaining genes are then subjected to the Benjamini-Hochberg procedure. The benefit is a gain in statistical power. By reducing the total number of hypotheses tested, the multiple testing penalty is less severe, allowing more true positives (expressed genes with actual differential expression) to pass the adjusted $p$-value threshold.

The effect of filtering can be seen in the following histogram:-

```{r histogram_vs_filtered}
mutate(results_annotated, Filtered = is.na(padj)) %>% 
  ggplot(aes(x = pvalue, fill = Filtered)) + geom_histogram(alpha = 0.4)
```

The filtered group (in blue) represents the low-count genes that were removed. The distribution is typically nearly uniform or even shows a slight peak towards the lower $p$-values. If these low-power genes were included, the overall flat null distribution needed for accurate FDR control would be slightly inflated near zero, leading to a harsher multiple testing penalty.

The non-Filtered Group (e.g., shown in red) represents the genes with sufficient expression to be tested. This is the set of $p$-values actually used for the Benjamini-Hochberg adjustment. This distribution should show a clear, desirable pattern: a strong peak near $p=0$ (the true differentially expressed genes) and a flat, uniform distribution from $\sim0.05$ to $1$ (the true null hypotheses).

By removing the "Filtered" genes, the adjusted $p$-values (`padj`) are calculated only on the well-behaved "Non-Filtered" set, resulting in more significant calls for the well-expressed genes.

If the details above seem complex, remember that `DESeq2` will do these automatically without you having to think about them. If we think this behaviour isn't desirable, or are curious to see the results without any adjustment, we can set the argument `independentFiltering = FALSE` in the `results` function.

## Shrinking the log fold-changes

`DESeq2` provides an estimate, for each gene, of the difference in mean expression between our groups. However, in the same way that the raw pvalues can be improved by the adjustment described about, we can also get better estimates of the log fold-changes (LFC).

When we made the MA-plot in the previous section we saw a fanning effect at lower expression levels. A technique called "shrinkage" helps to address this as the "shrunken" log fold-change is a better measure of biological magnitude for ranking genes.

Log fold-change shrinkage, implemented in `DESeq2` via the `lfcShrink()` function, uses a statistical technique called Bayesian shrinkage (or an Empirical Bayes approach) to address this.

It works by:

-   "Borrowing" Information: It assumes that most genes are not differentially expressed (i.e., most true LFCs are near zero).

-   "Shrinking": For genes with low counts (low confidence in the LFC), it shrinks their estimated LFC closer to zero.

-   Leaving Alone: For genes with high counts (high confidence in the LFC), the shrinkage effect is minimal, leaving the raw LFC largely untouched.

To use `lfcShrink` we have to supply the initial run of the `DESeq` pipeline (saved as `de_condition` in our case) and pay careful attention to the number of the coefficient that we want to apply shrinkage to. Running the `resultsNames` function prints that names of the coefficients, so `TGF_vs_CTR` is numbered coefficient 3. Printing the `results_final` object allows us to check as name of the contrast is printed to the screen.

```{r make_shruken_results}
resultsNames(de_condition)
results_final <- lfcShrink(de_condition, coef = 3)
results_final
```

Let's remind ourselves of the MA- plot of the raw differential expression results

```{r plotMA_raw}
results_raw <- results(de_condition)
plotMA(results_raw)
```

Looking at the "shrunken" results

```{r plotMA_shruknen}
plotMA(results_final)
```

The shrinkage technique will only change the log$_2$ fold-changes and **not the adjusted or raw p-values**. The purpose of shrinkage is to make the magnitude of the effect reliable for ranking genes, visualizing them in an MA plot, and filtering based on a minimum LFC threshold (e.g., `Log2FoldChange` \> 1). We can create a finalised results table by joining the annotation as before.

```{r add_annotation_to_final_results}
results_final <- as.data.frame(results_final) %>% 
  tibble::rownames_to_column("ENSEMBL") %>% 
  left_join(anno) %>% 
  filter(!duplicated(ENSEMBL)) %>% 
  arrange(padj) 
```

# Investigating particular gene sets

Extracellular Matrix (ECM) genes serve as the blueprint and building materials for the structural and biochemical changes that promote cancer progression. We might hypothesise that the expression of these genes would be altered after treatment with TGF

For the Extra-Cellular Matrix (ECM) pathway we can extract all genes as follows once we know the GO ID:-

```{r getECM_genes}
## The pull function from dplyr is used to extract a particular column
library(org.Hs.eg.db)
pathway_genes <- AnnotationDbi::select(org.Hs.eg.db,
                                       keys = "GO:0030198",
                                       keytype = "GO",
                                       columns="ENSEMBL") %>% pull(ENSEMBL)
```

We will now make a few plots to explore whether the genes belonging to this pathway have a tendency to be differentially-expressed (**DE**). Starting with a volcano plot (made by-hand this time), we will label the points according to whether their `ENSEMBL` ID is one of the genes belonging to the pathway.

```{r volcano_vs_ECM}
results_final %>% 
  mutate(ECM_Gene = ENSEMBL %in% pathway_genes) %>% 
  ggplot(aes(x = log2FoldChange, y = -log10(padj), col = ECM_Gene, alpha = ECM_Gene)) + geom_point() + scale_colour_manual(values = c("black", "red")) + scale_alpha_manual(values=c(0.1,1))
```

It certainly *looks* like some of these genes are DE. Another related plot is to look at the statistical significance (-log$_{10}$ adjusted p-value) for ECM and other genes separately.

```{r padj_vs_ECM_genes}
results_final %>% 
  mutate(ECM_Gene = ENSEMBL %in% pathway_genes) %>% 
  ggplot(aes(x = ECM_Gene, y = -log10(padj))) + geom_boxplot()
```

Again, the significance of ECM genes looks higher. Our next visualisation could be a heatmap, which if you recall from the previous section can be created using the `pheatmap` package. The variance stabilised data produced by `vst` is a good choice for this type of visualisation. We first make sure all the ENSEMBL IDs for the pathway are actually in our dataset, and get the VST values for these genes.

We then remove any rows with low variance, and look-up the gene symbols to be used to label the rows.

```{r heatmap_of_ECM, fig.width=10,fig.height=10, message=FALSE}
library(pheatmap)
vsd <- vst(dds)

## make sure all ENSEMBL IDs are in the dataaset
pathway_genes <- pathway_genes[pathway_genes %in% rownames(dds)]

## Get the VST values for these 
heatmap_data <- assay(vsd)[pathway_genes,]

## Remove rows with low variance

heatmap_data <- heatmap_data[rowVars(heatmap_data) >0.005, ]

row_labs <- heatmap_data %>% data.frame() %>% tibble::rownames_to_column("ENSEMBL") %>% 
  left_join(results_final) %>% 
  pull(SYMBOL)

samp_anno <- data.frame(colData(dds)) %>% dplyr::select(condition, Treated)

pheatmap(heatmap_data,
         annotation_col = samp_anno,scale="row",
         labels_row = row_labs)
```

Again, this shows genes whose expression seems to be affected by TGF. All these plots are interesting observations, but not concrete scientific proof.

To start to ascribe some significance to the finding we start by defining how many ECM genes we have in our data:-

```{r get_ECM_genes}
n_ECM_genes <- filter(results_final, ENSEMBL %in% pathway_genes) %>% nrow
n_ECM_genes
```

Next, how many genes are DE. Let's use a loose definition of an adjusted p-value less than 0.05.

```{r get_DE_genes}
n_DE_genes <- filter(results_final, padj < 0.05) %>% nrow()
n_DE_genes
```

Finally, how many of our ECM genes are also DE

```{r get_ECM_DE_genes}
n_ECM_DE_genes <- filter(results_final, padj < 0.05,ENSEMBL %in% pathway_genes) %>% nrow()
n_ECM_DE_genes
```

If our gene list was just a really random set of genes, with no relation to the underlying biology, then we would naturally expect some number of ECM genes to occur **by chance alone**. To get a handle on how many we might expect we can run a small simulation.

```{r sim_how_many_ECM}
n_ECM_genes <- filter(results_final, ENSEMBL %in% pathway_genes) %>% nrow
n_DE_genes <- filter(results_final, padj < 0.05) %>% nrow()

ECM_rand <- NULL

for(i in 1:1000){
ECM_rand[i] <- results_final %>% 
  slice_sample(n = n_DE_genes) %>% 
  filter(ENSEMBL %in% pathway_genes) %>% 
  nrow()
}

```

### Exercise

Use the code above to simulate how many ECM genes we might reasonably expect in a random gene list with the same length as our list of DE genes. Make a histogram of the results and make sure you understand the code. Is the **actual number** of ECM genes that we found to be DE consistent with this distribution?

::: {.callout-note collapse="true"}
# Solution

```{r sim_histogram}

## Running the code

n_ECM_genes <- filter(results_final, ENSEMBL %in% pathway_genes) %>% nrow
n_DE_genes <- filter(results_final, padj < 0.05) %>% nrow()

ECM_rand <- NULL

for(i in 1:1000){
ECM_rand[i] <- results_final %>% 
  slice_sample(n = n_DE_genes) %>% 
  filter(ENSEMBL %in% pathway_genes) %>% 
  nrow()
}

data.frame(ECM_rand) %>% 
  ggplot(aes(x = ECM_rand)) + geom_histogram() + geom_vline(xintercept = n_ECM_DE_genes, col = "red") + geom_vline(xintercept = median(ECM_rand),col="blue")

```

The number of ECM genes we observed was `r n_ECM_DE_genes` whereas the histogram shows we would expect around `r median(ECM_rand)`. It certainly seems like there more ECM genes than we would expect by chance.
:::

To formalise the test, we can then annotate each gene in our results according to whether it belongs to this pathway, and whether it is DE or not.

```{r cross_tab_ECM_DE}
go_table <- mutate(results_final, 
                   inPathway = ENSEMBL %in% pathway_genes,
                   isDE = padj < 0.05 )
go_table %>% 
  slice_head(n = 10) %>% 
  dplyr::select(SYMBOL, inPathway, isDE)
```

Cross-tabulating the two new columns gives a basis for a statistical test

```{r ECM_DE_2_by_2}
table(go_table$inPathway, go_table$isDE)
```

The Fisher's exact test or chi-squared test (as seen here) can then be used

```{r ECM_DE_chisquared}
chisq.test(table(go_table$inPathway, go_table$isDE))
```

We now have a p-value that is statistically-significant and can conclude that genes in the ECM pathway appear in our gene list more than we would expect by chance.

# Pathways analysis

We have of course picked ECM because it fit with a hypothesis we had about the dataset. It may not be the most significant pathway of interest, and probably not the only one either.

In reality it would be impractical to test all possible pathways in this manner, so there are a number of Bioconductor packages that automate the process. There are two main methodologies with the key distinction being whether we are happy to draw an arbitrary cut-off on the adjusted p-value and possibly LFC (*Threshold-based* or *Over-representation* analysis) or not (*Gene Set Enrichment Analysis (GSEA)*). Although we will use a single package that allows both methods, there are many other packages and websites available. Fortunately they mostly tend to use the same input(s).

## Threshold-based Gene Set Testing

*Threshold-based* or *Over-representation* analysis is used once we have decided a list of DE genes that we are happy with. The analysis then looks for gene sets that are *over-represented*, or occur more than we would expect by chance.

`clusterProfiler` is a Bioconductor package for pathways and downstream analysis and it's main advantage is that it provides some nice visualisation methods.

The function for over-representation analysis on Gene Ontologies is `enrichGO` which requires the IDs of genes found to be DE (`sigGenes`) and the IDs of *all* genes in the dataset (`universe`). It uses the `org.Hs.eg.db` package to map between gene names and biological pathways.

:::{.callout-note}

Unlike the `DESeq` workflow in the previous section, which reports **all** genes regardless of their significance, `enrichGO` only reports *significant* pathways based on the `qvalueCutoff` and `pvalueCutoff` arguments. If you want to see all the results regardless of significance you can set these values to 1.

The `p.adjust` and `qvalue` columns refers to two separate but related methods for multiple testing. `p.adjust` uses the the Benjamini-Hochberg ($\text{BH}$) method (also called $\text{FDR}$ or $\text{BH}$), which is a common and robust method for controlling the $\text{FDR}$. This is a step-up method that adjusts the raw $P$-value for each term. If you set a $\text{BH}$ cutoff of $0.05$, you are stating that you expect at most 5% of your rejected null hypotheses (your significant terms) to be false discoveries (i.e., enriched by chance). Therefore the value in the $\text{p.adjust}$ column is the lowest $\text{FDR}$ you can tolerate while still declaring that specific term significant.

The `qvalue` column comes from a method developed by John Storey, often implemented via the `qvalue` R package, which is frequently used for high-throughput data. The $\text{Q}$-value is an estimate of the minimum expected $\text{FDR}$ incurred when declaring a specific term significant. Unlike the $\text{BH}$ method, the $\text{Q}$-value method estimates the proportion of true null hypotheses ($\pi_0$) present in the data, leading to a potentially more powerful (less conservative) adjustment. If a term has a $\text{Q}$-value of $0.01$, it means that if you choose that value as your significance cutoff, you expect 1% of the terms declared significant to be false positives. Consequently the value in the $\text{qvalue}$ column is generally lower (more stringent) than the $\text{p.adjust}$ value because it uses the estimated $\pi_0$ to adjust the calculation.

:::

```{r echo = FALSE, warning=FALSE, message=FALSE}
library(clusterProfiler)
```


```{r enrichGO_run, message=FALSE, warning=FALSE, cache = TRUE}
library(clusterProfiler)
universe <- results_final %>% pull(ENSEMBL)
sigGenes <- results_final %>% 
  filter(padj < 0.05) %>% pull(ENSEMBL)

enrich_go <- enrichGO(
  gene= sigGenes,
  OrgDb = org.Hs.eg.db,
  keyType = "ENSEMBL",
  ont = "BP",
  universe = universe,
  qvalueCutoff = 0.05,
  readable=TRUE
)

```

The result of `enrichGo` can be turned into a data frame for easier interpretation.

```{r enrich_go_as_df}
enrich_go %>% data.frame %>% 
  slice_head(n = 10) %>% 
  select(-geneID)
```

The output data frame is using the same approaches discussed above and the `GeneRatio` and `BgRatio` columns tell you for each row (pathway) how many genes in that pathway were found in the DE genes (`GeneRatio`), and in the background (`BgRatio`). The `FoldEnrichment` indicates how many more times each pathway is represented than you would expect. Somewhat reassuringly the ECM pathway is found among these most significant pathways. A dot plot can show us the most enriched pathways, their statistical significance, and the size of each.

```{r enrichGO_dotplot, fig.height=8}
enrichplot::dotplot(enrich_go,showCategory=20)
```

You might notice that the names of some pathways, and the numbers of genes they contain are extremely similar. For example `extracellular matrix organization` and `extracellular structure organization`. This is because Gene Ontologies are not mutually exclusive and can comprise the same genes. The results can therefore give a false impression of how many biological functions are being represented amongst the results. Overlaps between gene sets can also be visualised using an "Upset plot" - an alternative to a venn diagram. The connected dots in the bottom panel show genes that are shared between different pathways, and the number of these genes is displayed in the bar chart.

```{r enrichGO_upset, message=FALSE, warning=FALSE}
enrichplot::upsetplot(enrich_go)
```

The `emapplot` function is another way of identifying redundancy and clustering the enrichment results into broader biological themes. For instance, terms like "cell proliferation," "cell division," and "mitotic nuclear division" would all cluster together, indicating they represent the single, large theme of "cell cycle."

Each node in this plot represents a significantly enriched pathway or GO term. Whereas an edge (line) connects two nodes if their underlying gene sets overlap significantly (i.e., they share many common genes).

```{r enrichGO_enrichPlot, fig.width=12}
enrich_go <- enrichplot::pairwise_termsim(enrich_go)
emapplot(enrich_go)
```

A gene-concept network plot (`cnetplot`) depicts the linkages of genes and biological concepts (e.g. GO terms or KEGG pathways) as a network. This plot can identify the core "hub" genes (genes with high connectivity) that are common to multiple enriched pathways. These hub genes are often considered the most critical players driving the observed biological change.

```{r, cnetplot, fig.width=12,fig.height=12}
cnetplot(enrich_go)
```

The`heatplot` is another way of visualising pathway overlaps. In this plot, each column is a gene and a black box indicating if that gene features in a given pathway.

```{r heatplot, fig.width=12}
heatplot(enrich_go, showCategory = 10)
```

Finally, the `treeplot` function performs hierarchical clustering of enriched terms. It relies on the pairwise similarities of the enriched terms calculated by the `pairwise_termsim()` function, which by default usese the Jaccard’s similarity index (JC).

```{r treeplot, message=FALSE, warning=FALSE, fig.width=12}
enrich_go <- enrichplot::pairwise_termsim(enrich_go)
enrichplot::treeplot(enrich_go)
```


### "Simplifying" the GO results

As noted, GO terms contain a lot of redundancy due to its hierarchical nature. We can however tackle this issue using the `simplify` function. In order to understand the impact we will first make a note of how many pathways are in the un-simplified output.



```{r} 
enrich_go %>% data.frame() %>% nrow
```


"Similarity" in this case refers to semantic similarity as implemented in the `GOSemSim` package. Semantic similarity, in the context of Gene Ontology (GO),cis a quantitative measure of how functionally related two GO terms are. It goes beyond simple gene sharing by assessing the terms' proximity within the GO hierarchy (the Directed Acyclic Graph or DAG). Two terms are highly similar if they share a common ancestor deep in the hierarchy, indicating a functional relationship, regardless of whether their gene lists overlap perfectly. This method ensures that terms covering the same core biological concept are grouped together.

If two or more GO terms are found to be highly similar (i.e., their similarity score meets or exceeds the defined cutoff), `simplify()` considers them redundant and removes one of them by for example picking the term with the most significant p-value.

```{r simplifying, cache = TRUE}
## This may take a while to run

enrich_go_simplified <- simplify(enrich_go)
enrich_go_simplified %>% data.frame %>% slice_head(n = 10)
```

```{r}
enrich_go_simplified %>% data.frame %>% nrow()
```


Compare the number of rows (terms) in the original enrichment result to the simplified result. You should see a significant reduction in the total count of enriched terms, confirming that redundancy was successfully removed. We can also repeat some of the same plots as above

```{r emapplot-simplified, fig.width=12}
emapplot(enrich_go_simplified)
```

```{r cnetplot-simplified, fig.width=12}
cnetplot(enrich_go_simplified)
```

## Gene set enrichment analysis (GSEA)

An appealing feature of the **GSEA** method is that it does not require us to impose arbitrary cut-offs on the dataset to decide what is DE or not. Instead it takes a set of *ranked statistics* for *all* genes and looks for sets of genes that occur either at the top or bottom of the list. As GSEA uses the *direction* of a test result (either up- or down-regulated) the test statistics themselves must have a positive or negative sign. Although the p-values cannot therefore be used for this purpose, they can be transformed using the same equation used in the volcano plot (-10 x log$_{10}$) and multiplying by the "sign" of the LFC (i.e. +1 or -1).

The steps in producing the input required for GSEA are i) calculating and retrieving the ranking statistics ii) naming each one according to a chosen identifier (`ENSEMBL` or `ENTREZID` for example). The `clusterProfiler` package also includes an implementation of the GSEA algorithm (via the `fgsea` package), and the function works in much the same way as `enrichGO` from above.

```{r gseGO_run, warning = FALSE, cache = TRUE}

ranked_genes <- results_final %>% 
  mutate(Score = sign(log2FoldChange)*-log10(padj)) %>% 
  arrange(desc(Score)) %>% 
  filter(!is.na(Score))
  
geneList <- pull(ranked_genes, Score)
names(geneList) <- pull(ranked_genes, ENSEMBL)
  
gse_GO  <- gseGO(geneList = geneList,
        OrgDb = org.Hs.eg.db,
        ont = "BP",keyType = "ENSEMBL")

```

The results may not necessarily be the same as the over-representation analysis, since GSEA is answering a slightly different question.

```{r gseGO_show}
gse_GO %>% as.data.frame %>% 
  slice_head(n = 10) %>% 
  ## don't show the core enrichment to make a display a bit cleaner
  select(-core_enrichment)
```


As GSEA uses *all* of the genes that were present in the dataset, it has also used all genes in a pathway to calculate the enrichment. However, to narrow-down the interpretation of a pathways the core enrichment or leading edge of a GSEA can be used. This refers to the subset of genes within an enriched pathway that primarily drives the enrichment signal. It represents the genes that are most responsible for the pathway receiving its high Enrichment Score and thus its significance.

```{r}
## show the core enrichment for the top pathway
gse_GO %>% as.data.frame %>% 
  slice_head() %>% 
  select(core_enrichment)
```



An overview of the results can be provided by a "ridge plot". This allows comparison of the test statistics for each of the top enriched pathways.

```{r gseGO_ridgeplot}
ridgeplot(gse_GO)
```

An upset plot can still be produced, but this time the distribution of statistics for overlapping categories can be produced.

```{r gseGO_upset}
enrichplot::upsetplot(gse_GO)
```

GSEA introduces a new type of plot that summarizes the entire analysis for a single pathway and is central to interpreting its results. Shown below is the GSEA enrichment plot for the pathway with the most extreme enrichment score.

```{r gseGO_gseaplot_up, fig.height=8}

top_gsea <- gse_GO %>% as.data.frame %>% 
  slice_max(abs(enrichmentScore)) %>% 
  pull(ID)

top_gsea_ID <- gse_GO %>% as.data.frame %>% 
  slice_max(abs(enrichmentScore)) %>% 
  pull(Description)

enrichplot::gseaplot2(gse_GO,geneSetID = top_gsea,title = top_gsea_ID)
```

The top panel shows the core evidence for enrichment. The line is a running sum statistic that measures the degree of enrichment. It starts at zero and increases every time a gene belonging to the pathway is encountered in the ranked list, whereas it slightly decreases when a gene not in the pathway is encountered. The peak of this curve is the maximum Enrichment Score ($\text{ES}$). If the peak is on the left (positive), the pathway is up-regulated; if the peak is on the right (negative), the pathway is down-regulated. $\text{GSEA}$

The black vertical lines beneath the curve are the pathway "barcode". Each line represents a single gene from the pathway, placed at its exact ranked position. The clustering of these ticks—either on the far left or far right—provides the visual evidence for the calculated $\text{ES}$.

The Bottom Panel displays the value of the statistic used to rank all genes. This confirms that the genes on the far left of the plot have the most positive values (high $\text{LFC}$) and those on the far right have the most negative values (low $\text{LFC}$), providing context for the directional enrichment observed in the top panel.

In the example plot there is a high concentration of vertical black lines to the right of the plot - coinciding with the lowest point of the green line. This is where the majority of genes for this pathway can be found in the ranked gene list, and therefore we conclude there is a tendency for genes in this pathway to be DE.


## Exercise

-   In addition to enriched GO terms, `clusterProfiler` can also find enriched [KEGG](https://www.genome.jp/kegg/) terms using the `enrichKEGG` function. There are a couple of changes that are required from `enrichGO`
    -   `ENTREZID` has to be used as the identifer type
    -   the user must input an appropriate [organism code](https://www.genome.jp/kegg/catalog/org_list.html). The code for humans is `hsa`.
-   Use the `enrichKEGG` function to identify enriched KEGG terms in the analysis.
-   (Optional) If you have time, use the `gseKEGG` to perform GSEA using KEGG terms.

::: {.callout-note collapse="true"}

### Solution

```{r enrichKEGG}
## KEGG tools require ENTREZ ID

sigGenesEntrez <- results_final %>% 
  filter(padj < 0.05) %>% pull(ENTREZID)

enrich_kegg <- enrichKEGG(gene = sigGenesEntrez,
                       organism = "hsa",)
as.data.frame(enrich_kegg) %>% slice_head(n = 10)


```




```{r gseKEGG}
ranked_genes <- results_final %>% 
  mutate(Score = sign(log2FoldChange)*-log10(padj)) %>% 
  arrange(desc(Score)) %>% 
  filter(!is.na(Score)) %>% 
  filter(!is.na(ENTREZID)) %>% 
  filter(!duplicated(ENTREZID))
  
geneList <- pull(ranked_genes, Score)
names(geneList) <- pull(ranked_genes, ENTREZID)
  
gse_GO  <- gseKEGG(geneList = geneList,
                   organism = "hsa")

gse_GO %>% data.frame() %>% slice_head(n = 10)
```


:::

## Which database to use?

We have looked the two main types of test supported by `clusterProfiler` using a database of Gene Ontology (GO) terms as a reference. These were implemented in the `enrichGO` and `gseGO` functions respectively. The above exercise used KEGG instead. A nice feature of `clusterProfiler` is that you can test different databases for significant pathways with few changes to your code. Some of the different databases and the corresponding function to use are summarised below

+------------------------------------------------------------------------------------------------------------------------------------+---------------------+---------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| Database                                                                                                                           | Function            | Primary Focus                                                             | Pros                                                                                                | Cons                                                                                                                   |
+====================================================================================================================================+=====================+===========================================================================+=====================================================================================================+========================================================================================================================+
| [Gene Ontology (GO)](https://yulab-smu.top/biomedical-knowledge-mining-book/clusterprofiler-go.html)                               | -   \`enrichGO\`    | Biological Process (BP), Molecular Function (MF), Cellular Component (CC) | -   **Broadest Coverage:** Covers nearly all known genes in most species.                           | -   **High Redundancy:** Similar terms often overlap significantly.                                                    |
|                                                                                                                                    |                     |                                                                           |                                                                                                     |                                                                                                                        |
|                                                                                                                                    | -   \`gseGO\`       |                                                                           | -   **Hierarchical:** Allows for semantic similarity grouping (`simplify()`).                       | -   **Functional Ambiguity:** Terms can be very broad.                                                                 |
+------------------------------------------------------------------------------------------------------------------------------------+---------------------+---------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| [KEGG (Kyoto Encyclopedia of Genes and Genomes)](https://yulab-smu.top/biomedical-knowledge-mining-book/clusterprofiler-kegg.html) | -   \`enrichKEGG\`  | Metabolic & Regulatory Pathways                                           | -   **Visual Maps:** Provides detailed, manually drawn pathway diagrams.                            | -   **Limited Coverage:** Focused primarily on well-studied pathways.                                                  |
|                                                                                                                                    |                     |                                                                           |                                                                                                     |                                                                                                                        |
|                                                                                                                                    | -   \`gseKEGG\`     |                                                                           | -   **Focus on Mechanism:** Excellent for examining core signaling and metabolic processes          | -   **Licensing/Updates:** Access can be restricted/less frequently updated in free versions.                          |
+------------------------------------------------------------------------------------------------------------------------------------+---------------------+---------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| [Reactome](https://yulab-smu.top/biomedical-knowledge-mining-book/reactomepa.html)                                                 | -   `enrichPathway` | Molecular Events & Reactions                                              | -   **Mechanistic Detail:** Highly curated, evidence-based sequence of molecular events (reactions) | -   **Bias toward Human:** Predominantly focused on human biology.                                                     |
|                                                                                                                                    |                     |                                                                           |                                                                                                     |                                                                                                                        |
|                                                                                                                                    | -   \`gsePathway\`  |                                                                           | -   **Non-Redundant Structure:** Less overlap between main pathways than in GO.                     | -    **Pathway Fragmentation:** High detail can make pathways appear fragmented.                                       |
+------------------------------------------------------------------------------------------------------------------------------------+---------------------+---------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| [WikiPathways](https://yulab-smu.top/biomedical-knowledge-mining-book/wikipathways-analysis.html)                                  | -   `enrichWP`      | Community-Driven, Open Content                                            | -   **Flexible & Collaborative:** Allows any researcher to create, edit, and contribute.            | -   **Variable Quality:** Quality control is less stringent than curated databases.                                    |
|                                                                                                                                    |                     |                                                                           |                                                                                                     |                                                                                                                        |
|                                                                                                                                    | -   `gseWP`         |                                                                           | -   **Rapid Inclusion:** Quickly integrates novel and species-specific pathways.                    | -   **Inconsistent Scope:** Pathway scale and definition can be less uniform.                                          |
+------------------------------------------------------------------------------------------------------------------------------------+---------------------+---------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| [Disease Ontology](https://yulab-smu.top/biomedical-knowledge-mining-book/dose-enrichment.html)                                    | -   `enrichDO`      | Structured Vocabulary for Human Diseases                                  | -   **Hierarchical Structure:** DAG allows for GSEA and semantic clustering.                        | -   **Gene Association Reliability:** Associations are aggregated from multiple sources, meaning reliability can vary. |
|                                                                                                                                    |                     |                                                                           |                                                                                                     |                                                                                                                        |
|                                                                                                                                    | -   `gseDO`         |                                                                           | -   **Standardized:** Provides a single, clear terminology for classifying diseases.                | -   **Redundancy:** Hierarchical terms mean high-level parent terms can obscure specific results.                      |
+------------------------------------------------------------------------------------------------------------------------------------+---------------------+---------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+

: Summary of different databases that clusterProfiler can use

Ultimately, you will have to decide which database(s) are more appropriate for the interpretation of your results.


## Additional visualistion of KEGG pathways

The special feature of a KEGG pathway is its standardized, structured graphical representation as a set of computable maps. This means that visualisation with tools like `pathview` is possible. In the below we take a pathway such as "Lysosome", use it's standard KEGG layout and colour the genes involved in the pathway according to the LFC.


```{r pathview}
library(pathview)

# The KEGG ID you want to visualize
kegg_id <- "hsa04142"

# Organism code (hsa for human)
organism_code <- "hsa"

lfc_values <- pull(results_final, "log2FoldChange")
names(lfc_values) <- pull(results_final, "ENTREZID")

pathview(
  gene.data = lfc_values,
  pathway.id = "hsa04142",
  species = "hsa",
  low = "blue",
  mid = "gray",
  high = "red",
  kegg.native = TRUE,
  out.suffix = "lysosome_blue_red"
)
```

![](/files/training/bulk_rnaseq/hsa04142.lysosome_blue_red.png)

# Summary


We have covered many aspects of how to explore your RNA-seq results. You may wish to you as many, or as few of these, as possible to understand your data. Unfortunately, as a Bioinformatician I cannot tell you exactly which cut-offs and combination of databases are the most applicable for your data. The key takeaway is that success hinges on the initial phases of Quality Control (QC) and data normalization, which ensure the integrity of the downstream differential expression results. By combining  the statistical findings with our prior biological knowledge, we transform a list of numbers into a clear understanding of the altered pathways and functions, making the data truly interpretable and actionable.


:::{.callout-important}

Ultimately, the data tells a story, but you, as the researcher, must use your knowledge and judgment to determine the best lens through which to view it.

:::
