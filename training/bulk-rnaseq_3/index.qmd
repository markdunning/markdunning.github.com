---
title: "Introduction to RNA-Seq - Part 3"
author: Mark Dunning
date: 2025-10-25
theme: darkly
image: "/files/training/bulk_rnaseq/part3_preview.png"
---

# Overview

Further exploration of differential expression, followed by identifcation of biological pathways of interest

## Quick Start

This section follows on from [Part 1](/training/bulk-rnaseq_part1/index.html) and [Part 2](/training/bulk-rnaseq_part2/index.html) where we saw how to import raw RNA-seq counts into `DESeq2`, perform some quality assessment and then differential expression. Several packages are required, which can be downloaded with this code:-

```{r eval=FALSE}
source("https://raw.githubusercontent.com/markdunning/markdunning.github.com/refs/heads/master/files/training/bulk_rnaseq/install_bioc_packages.R")
```

The following will also assume you have created a `DESeq2` object in a folder called `Robjects` in your working directory. This can be downloaded with the following.

```{r eval=FALSE}
dir.create("Robjects/",showWarnings = FALSE)
download.file("https://github.com/markdunning/markdunning.github.com/raw/refs/heads/master/files/training/bulk_rnaseq/dds.rds",destfile = "Robjects/dds.rds")
```

# Differential expression with `DESeq2`

```{r echo=FALSE}
dds <- readRDS("Robjects/dds.rds")
```

In [Part 2](/training/bulk-rnaseq_part2/index.html) we dissected the `DESeq` workflow for differential expression in some detail. We also created a data frame for "annotating" the results with biological identifiers that are more recognisable.

```{r load-anno, message=FALSE, warning=FALSE}
library(org.Hs.eg.db)
anno <- AnnotationDbi::select(org.Hs.eg.db,keys=rownames(dds),
              columns=c("SYMBOL","GENENAME"),
              keytype="ENSEMBL")
# Have a look at the annotation
head(anno)
```

The code to perform differential expression and incorporate the annotations is given below.

```{r results-recap, message=FALSE, warning=FALSE}
library(DESeq2)
library(dplyr)
library(ggplot2)

de_condition <- DESeq(dds)

results_annotated <- results(de_condition, 
        contrast = c("condition", "TGF", "CTR"),
        tidy = TRUE) %>% 
  left_join(anno, by = c("row" = "ENSEMBL")) %>% 
  filter(!duplicated(row)) %>% 
  arrange(padj) %>% 
  ## removing the lfcSE column
  dplyr::select(-lfcSE)

results_annotated %>% 
  slice_head(n = 10)
```

# Filtering the differential expression results

The `results_annotated` tibble contains results for *all* the genes that appeared in our counts data, which could be many 10,000s of potential candidates for being biologically meaningful. Deciding which genes to take forward for further investigation can be quite subtle, and can depend on what your question of interest is. With the simplest criteria applied (e.g. an adjusted p-value of 0.05) you can still be faced with 1000s of genes to interpret. Of course, there are methods for identifying biological themes (see later). 


The `padj` and `log2FoldChange` in the results table are common quantities for filtering representing the statistical certainty and effect size respectively. In an ideal world, genes of interest should have a high degree of statistical certainty (extremely low p-value) and large effect size. We can be reasonably confident about the p-value adjustments that `DESeq2` performed, and we will discuss the `log2FoldChange` later.

At the moment we have almost 5,000 genes with an arbitrary `0.05` cutoff, but not all of them are going to be relevant to our question.

```{r}
dplyr::count(results_annotated, padj <0.05)
```

But wait, we also have some `NA` values. What's the deal with those?

## Why are some adjusted p-values "`NA`"?

`DESeq2` has already done some processing on the results to exclude genes with low expression level across the dataset that it deems to be unreliable and unlikely to be differential-expressed. The genes it filters out (those that have `NA` adjusted p-value) tend to have a lower value of `baseMean`.

```{r filter_vs_baseMean}
results_annotated %>% 
  ggplot(aes(x = is.na(padj), y = baseMean)) + geom_boxplot() + scale_y_log10()
```

The core principle is that genes with very low expression (low average normalized counts) have little power to be called differentially expressed, even if their true $\log_2$ fold change is comparatively large. By testing all genes, you incur a multiple testing penalty for these low-power genes, which reduces the number of genes that can be called significant overall.

The procedure first uses the mean of normalized counts (`baseMean`) across all samples as a filtering mechanism. Genes with very low expression have high $p$-values due to low statistical power (high variance relative to the mean), regardless of their true fold change. `DESeq2` determines an optimal cutoff for the `baseMean` that maximizes the number of genes called significant (`padj` < $\alpha$, where $\alpha$ is usually $0.1$ or $0.05$). This is done by testing a range of cutoffs and picking the one that yields the largest number of discoveries. Genes with mean counts below this optimal cutoff are removed (in practice their `padj` is set to `NA`). The remaining genes are then subjected to the Benjamini-Hochberg procedure.The benefit is a gain in statistical power. By reducing the total number of hypotheses tested, the multiple testing penalty is less severe, allowing more true positives (expressed genes with actual differential expression) to pass the adjusted $p$-value threshold.

The effect of filtering can be seen in the following histogram:-

```{r histogram_vs_filtered}
mutate(results_annotated, Filtered = is.na(padj)) %>% 
  ggplot(aes(x = pvalue, fill = Filtered)) + geom_histogram(alpha = 0.4)
```

The filtered group (in blue) represents the low-count genes that were removed. The distribution is often nearly uniform or even shows a slight peak towards the lower $p$-values. If these low-power genes were included, the overall flat null distribution needed for accurate FDR control would be slightly inflated near zero, leading to a harsher multiple testing penalty.

Non-Filtered Group (e.g., shown in red): This histogram represents the genes with sufficient expression to be tested. This is the set of $p$-values actually used for the Benjamini-Hochberg adjustment. This distribution should show a clear, desirable pattern: a strong peak near $p=0$ (the true differentially expressed genes) and a flat, uniform distribution from $\sim0.05$ to $1$ (the true null hypotheses).Conclusion: By removing the "Filtered" genes, the adjusted $p$-values ($\text{padj}$) are calculated only on the well-behaved "Non-Filtered" set, resulting in more significant calls for the well-expressed genes.

If the details above seem complex, remember that `DESeq2` will do these automatically without you having to think about them. If we think this behaviour isn't desirable, or are curious to see the results without any adjustment, we can set the argument `independentFiltering = FALSE` in the `results` function.

## Shrinking the log fold-changes

`DESeq2` provides an estimate, for each gene, of the difference in mean expression between our groups. However, in the same way that the raw pvalues can be improved by the adjustment described about, we can also get better estimates of the log fold-changes (LFC).

When we made the MA-plot in the previous section we saw a fanning effect at lower expression levels. Creates much cleaner, less noisy MA plots and heatmaps. A technique called "shrinkage" helps to address this as the "shrunken" log fold-change is a better measure of biological magnitude for ranking genes

Log fold-change shrinkage, implemented in `DESeq2` via the `lfcShrink()` function, uses a statistical technique called Bayesian shrinkage (or an Empirical Bayes approach) to address this.

It works by:

-   "Borrowing" Information: It assumes that most genes are not differentially expressed (i.e., most true LFCs are near zero).

-   "Shrinking": For genes with low counts (low confidence in the LFC), it shrinks their estimated LFC closer to zero.

-   Leaving Alone: For genes with high counts (high confidence in the LFC), the shrinkage effect is minimal, leaving the raw LFC largely untouched.

To use `lfcShrink` we have to supply the initial run of the `DESeq` pipeline (saved as `de_condition` in our case) and pay careful attention to the number of the coefficient that we want to apply shrinkage to. Running the `resultsNames` function prints that names of the coefficients, so `TGF_vs_CTR` is numbered coefficient 3. Printing the `results_final` object allows us to check as name of the contrast is printed to the screen.

```{r make_shruken_results}
resultsNames(de_condition)
results_final <- lfcShrink(de_condition, coef = 3)
results_final
```

Let's remind ourselves of the MA- plot of the raw differential expression results

```{r plotMA_raw}
results_raw <- results(de_condition)
plotMA(results_raw)
```

Looking at the "shrunken" results

```{r plotMA_shruknen}
plotMA(results_final)
```

The shrinkage technique will only change the log$_2$ fold-changes and **not the adjusted or raw p-values**. The purpose of shrinkage is to make the magnitude of the effect reliable for ranking genes, visualizing them in an MA plot, and filtering based on a minimum LFC threshold (e.g., `Log2FoldChange` > 1). We can create a finalised results table by joining the annotation as before.

```{r add_annotation_to_final_results}
results_final <- as.data.frame(results_final) %>% 
  tibble::rownames_to_column("ENSEMBL") %>% 
  left_join(anno) %>% 
  filter(!duplicated(ENSEMBL)) %>% 
  arrange(padj) 
```


# Investigating particular gene sets

Extracellular Matrix (ECM) genes serve as the blueprint and building materials for the structural and biochemical changes that promote cancer progression. We might hypothesise that the expression of these genes would be altered after treament with TGF

For the Extra-Cellular Matrix (ECM) pathway we can extract all genes as follows once we know the GO ID:-

```{r getECM_genes}
## The pull function from dplyr is used to extract a particular column
library(org.Hs.eg.db)
pathway_genes <- AnnotationDbi::select(org.Hs.eg.db,
                                       keys = "GO:0030198",
                                       keytype = "GO",
                                       columns="ENSEMBL") %>% pull(ENSEMBL)
```

We will now make a few plots to explore whether the genes belonging to this pathway have a tendency to be differentially-expressed. Starting with a volcano plot (made by-hand this time), we will label the points according to whether their `ENSEMBL` ID is one of the genes belonging to the pathway.


```{r volcano_vs_ECM}
results_final %>% 
  mutate(ECM_Gene = ENSEMBL %in% pathway_genes) %>% 
  ggplot(aes(x = log2FoldChange, y = -log10(padj), col = ECM_Gene, alpha = ECM_Gene)) + geom_point() + scale_colour_manual(values = c("black", "red")) + scale_alpha_manual(values=c(0.1,1))
```

It certainly *looks* like these genes are more significant than we might expect. Another related plot is to look at the statistical significance (-log$_{10}$ adjusted p-value) for ECM and other genes separately.

```{r padj_vs_ECM_genes}
results_final %>% 
  mutate(ECM_Gene = ENSEMBL %in% pathway_genes) %>% 
  ggplot(aes(x = ECM_Gene, y = -log10(padj))) + geom_boxplot()
```

Our next visualisation could be a heatmap, which if you recall from the previous section can be created using the `pheatmap` package. The variance stabilised data produced by `vst` is a good choice for this type of visualisation. We first make sure all the ENSEMBL IDs for the pathway are actually in our dataset, and get the VST values for these genes.

We then remove any rows with low variance, and look-up the gene symbols to be used to label the rows.


```{r heatmap_of_ECM, fig.width=10,fig.height=10, message=FALSE}
library(pheatmap)
vsd <- vst(dds)

## make sure all ENSEMBL IDs are in the dataaset
pathway_genes <- pathway_genes[pathway_genes %in% rownames(dds)]

## Get the VST values for these 
heatmap_data <- assay(vsd)[pathway_genes,]

## Remove rows with low variance

heatmap_data <- heatmap_data[rowVars(heatmap_data) >0.005, ]

row_labs <- heatmap_data %>% data.frame() %>% tibble::rownames_to_column("ENSEMBL") %>% 
  left_join(results_final) %>% 
  pull(SYMBOL)

samp_anno <- data.frame(colData(dds)) %>% dplyr::select(condition, Treated)

pheatmap(heatmap_data,
         annotation_col = samp_anno,scale="row",
         labels_row = row_labs)
```

Again, this shows genes whose expression seems to be affected by TGF. All these plots are interesting observations, but not concrete scientific proof.

To start to ascribe some significance to the finding we start by defining how many ECM genes we have in our data:-

```{r get_ECM_genes}
n_ECM_genes <- filter(results_final, ENSEMBL %in% pathway_genes) %>% nrow
n_ECM_genes
```
How many genes are differentially-expressed. Let's use a loose definition of an adjusted p-value less than 0.05.

```{r get_DE_genes}
n_DE_genes <- filter(results_final, padj < 0.05) %>% nrow()
n_DE_genes
```
Finally, how many of our ECM genes are also differentially-expressed

```{r get_ECM_DE_genes}
n_ECM_DE_genes <- filter(results_final, padj < 0.05,ENSEMBL %in% pathway_genes) %>% nrow()
n_ECM_DE_genes
```
If our gene list was just a really random set of genes with no relation to the underlying biology, then we would naturally expect some number of ECM genes to occur **by chance alone**. To get a handle on how many we might expect we can run a small simulation. 

```{r sim_how_many_ECM}
n_ECM_genes <- filter(results_final, ENSEMBL %in% pathway_genes) %>% nrow
n_DE_genes <- filter(results_final, padj < 0.05) %>% nrow()

ECM_rand <- NULL

for(i in 1:1000){
ECM_rand[i] <- results_final %>% 
  slice_sample(n = n_DE_genes) %>% 
  filter(ENSEMBL %in% pathway_genes) %>% 
  nrow()
}

```


### Exercise

# Solution

Use the code above to simulate how many ECM genes we might reasonably expect in a random gene list with the same length as our list of differentially-expressed genes. Make a histogram of the results and make sure you understand the code. Does the **actual number** of ECM genes that we found to be differentially-expressed consistent with this distribution?

:::{.callout-note collapse="true"}

```{r sim_histogram}

## Running the code

n_ECM_genes <- filter(results_final, ENSEMBL %in% pathway_genes) %>% nrow
n_DE_genes <- filter(results_final, padj < 0.05) %>% nrow()

ECM_rand <- NULL

for(i in 1:1000){
ECM_rand[i] <- results_final %>% 
  slice_sample(n = n_DE_genes) %>% 
  filter(ENSEMBL %in% pathway_genes) %>% 
  nrow()
}

data.frame(ECM_rand) %>% 
  ggplot(aes(x = ECM_rand)) + geom_histogram() + geom_vline(xintercept = n_ECM_DE_genes, col = "red") + geom_vline(xintercept = median(ECM_rand),col="blue")

```

The number of ECM genes we observed was `r n_ECM_DE_genes` whereas the histogram shows we would expect around `r median(ECM_rand)`. It certainly seems like there more ECM genes than we would expect by chance.

:::

To formalise the test, we can then annotate each gene in our results according to whether it belongs to this pathway, and whether it is differentially-expressed or not.


```{r cross_tab_ECM_DE}
go_table <- mutate(results_final, 
                   inPathway = ENSEMBL %in% pathway_genes,
                   isDE = padj < 0.05 )
go_table %>% 
  slice_head(n = 10) %>% 
  dplyr::select(SYMBOL, inPathway, isDE)
```

Cross-tabulating the two new columns gives a basis for a statistical test

```{r ECM_DE_2_by_2}
table(go_table$inPathway, go_table$isDE)
```


For a particular pathway we need to calculate how many genes were identified as differentially-expressed and compare to *how many we would be expect by chance*. Or in other words, if we repeatedly generated a list of differentially-expressed genes at random how many genes from this pathway would be expect to see.


The Fisher's exact test or chi-squared test (as seen here) can then be used

```{r ECM_DE_chisquared}
chisq.test(table(go_table$inPathway, go_table$isDE))
```
We now have a p-value that is statistically-significant and can conclude that genes in the ECM pathway appear in our gene list more than we would expect by chance.



# Pathways analysis

We have of course picked ECM because it fit with a hypothesis we had about the dataset. It may not be the only pathway of interest, and probably not the only one either.

In reality it would be impractical to test all possible pathways in this manner, so there are a number of Bioconductor packages that automate the process


## Threshold-based Gene Set Testing

*Threshold-based* or *Over-representation* analysis is used once we have decided a list of differentially-expressed genes that we are happy with. The analysis then looks for gene sets that are *over-represented*, or occur more than we would expect by chance.

`clusterProfiler` is a Bioconductor package for pathways and downstream analysis and it's main advantage is that it provides some nice visualisation methods.

The function for over-representation analysis on Gene Ontologies is `enrichGO` which requires the IDs of genes found to be differentially-expressed (`sigGenes`) and the IDs of *all* genes in the dataset (`universe`). It uses the `org.Hs.eg.db` package to map between gene names and biological pathways.

```{r enrichGO_run, message=FALSE, warning=FALSE}
library(clusterProfiler)
universe <- results_final %>% pull(ENSEMBL)
sigGenes <- results_final %>% 
  filter(padj < 0.05) %>% pull(ENSEMBL)

enrich_go <- enrichGO(
  gene= sigGenes,
  OrgDb = org.Hs.eg.db,
  keyType = "ENSEMBL",
  ont = "BP",
  universe = universe,
  qvalueCutoff = 0.05,
  readable=TRUE
)

```

The result of `enrichGo` can be turned into a data frame for easier interpretation.

```{r enrich_go_as_df}
enrich_go %>% data.frame %>% 
  slice_head(n = 10)
```

Somewhat reassuringly the Extracellular Matrix pathways is found amongst these most significant pathways. A dot plot can show us the most enriched pathways, and the size of each.

```{r enrichGO_dotplot, fig.height=8}
dotplot(enrich_go,showCategory=20)
```

Overlaps between gene sets can also be visualised using an "Upset plot" - an alternative to a venn diagram.

```{r enrichGO_upset}
enrichplot::upsetplot(enrich_go)
```


Relationships between the identified categories can be found using `emapplot`.

```{r enrichGO_enrichPlot, fig.width=12}
enrich_go <- enrichplot::pairwise_termsim(enrich_go)
emapplot(enrich_go)
```



## Gene set enrichment analysis (GSEA)

An appealing feature of the **GSEA** method is that it does not require us to impose arbitrary cut-offs on the dataset to decide what is differentially-expressed or not. The steps in producing the input required for GSEA are i) retrieving the ranked statistics ii) naming each one according to a chosen identifier (`ENSEMBL` or `ENTREZID` for example).

The `clusterProfiler` package also includes an implementation of the GSEA algorithm, and the function works in much the same way as `enrichGO` from above.

```{r gseGO_run}

ranked_genes <- results_final %>% 
  mutate(Score = sign(log2FoldChange)*-log10(padj)) %>% 
  arrange(desc(Score)) %>% 
  filter(!is.na(Score))
  
geneList <- pull(ranked_genes, Score)
names(geneList) <- pull(ranked_genes, ENSEMBL)
  
gse_GO  <- gseGO(geneList = geneList,
        OrgDb = org.Hs.eg.db,
        ont = "BP",keyType = "ENSEMBL")

```

```{r gseGO_show}
gse_GO %>% as.data.frame %>% 
  slice_head(n = 10)
```

An overview of the results can be provided by a "ridge plot". This allows comparison of the test statistics for each of the top enriched pathways.

```{r gseGO_ridgeplot}
ridgeplot(gse_GO)
```

An upset plot can still be produced, but this time the distribution of statistics for overlapping categories can be produced.

```{r gseGO_upset}
enrichplot::upsetplot(gse_GO)
```

The results confirm that the ECM pathway has many differentially-expressed genes (more than we would expect by chance). Moreover, there is a tendancy for these genes to be up-regulated; as indicated by the high positive enrichment score. Another way to visualise the GSEA results, that is typically produced from the GSEA java app, is the so-called enrichment plot.

```{r gseGO_gseaplot_0030198}
gseaplot(gse_GO,geneSetID = "GO:0030198")
```

The enrichment plot for a gene set with a high negative enrichment score reveals a different pattern.

```{r gseGO_gseaplot_0002283}
gseaplot(gse_GO,geneSetID = "GO:0002283")
```

## Exercise

::: exercise
-   In addition to enriched GO terms, `clusterProfiler` can also find enriched [KEGG](https://www.genome.jp/kegg/) terms using the `enrichKEGG` function. There are a couple of changes that are required from `enrichGO`
    -   `ENTREZID` have to be used as the identifer type
    -   the user must input an appropriate [organism code](https://www.genome.jp/kegg/catalog/org_list.html). The code for humans is `hsa`.
-   Use the `enrichKEGG` function to identify enriched KEGG terms in the analysis.
-   (Optional) If you have time, use the gseKEGG to perform GSEA using KEGG terms.
:::

```{r}

```

Other visualisation methods using the clusterProfiler output can be found here:-

https://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html

# Appendix: Annotation with the biomaRt resource

The Bioconductor package have the convenience of being able to make queries offline. However, they are only available for certain organisms. If your organism does not have an `org.XX.eg.db` package listed on the Bioconductor annotation page (http://bioconductor.org/packages/release/BiocViews.html#\_\_\_AnnotationData), an alternative is to use biomaRt which provides an interface to the popular biomart annotation resource.

The first step is to find the name of a database that you want to connect to.

```{r eval=FALSE}
library(biomaRt)
listMarts()
ensembl=useMart("ENSEMBL_MART_ENSEMBL")
# list the available datasets (species). Replace human with the name of your organism
listDatasets(ensembl) %>% filter(grepl("Human",description))
```

```{r eval=FALSE}
ensembl = useDataset("hsapiens_gene_ensembl", mart=ensembl)
```

Queries to `biomaRt` are constructed in a similar way to the queries we performed with the `org.Hs.eg.db` package. Instead of `keys` we have `filters`, and instead of `columns` we have attributes. The list of acceptable values is much more comprehensive that for the `org.Hs.eg.db` package.

```{r eval=FALSE}
listFilters(ensembl) %>% 
    filter(grepl("ensembl",name))
```

```{r eval=FALSE}
listAttributes(ensembl) %>% 
    filter(grepl("gene",name))
```

An advantage over the `org..` packages is that positional information can be retrieved

```{r eval=FALSE}
attributeNames <- c('ensembl_gene_id', 'entrezgene_id', 'external_gene_name', "chromosome_name","start_position","end_position")

getBM(attributes = attributeNames,
      filters = "ensembl_gene_id",
      values=top_genes,
      mart=ensembl)
```
