---
title: "Introduction to R - Part 3"
author: Mark Dunning
date: today
image: /files/training/r/part3_preview.png
theme: darkly
---

# Overview

Further data exploration and manipulation with `ggplot2` and `dplyr`

## Topics covered

-   Customising ggplot2 plots
-   Summarising data
-   Group-based summaries
-   Joining data
-   Data Cleaning

Lets make sure we have read the gapminder data into R and have the relevant packages loaded.

```{r message=FALSE,warning=FALSE}
## Checks if the required file is present, and downloads if not

if(!file.exists("raw_data/gapminder.csv")) {
  dir.create("raw_data/",showWarnings = FALSE)
download.file("https://raw.githubusercontent.com/markdunning/markdunning.github.com/refs/heads/master/files/training/r/raw_data/gapminder.csv", destfile = "raw_data/gapminder.csv")
}
```

We also discussed in the previous part(s) how to read the example dataset into R. We will also load the libraries needed.

```{r message=FALSE}
library(readr)
library(ggplot2)
library(dplyr)
gapminder <- read_csv("raw_data/gapminder.csv")
```

## Customising a plot

Now make a scatter plot of gdp versus life expectancy as we did in the previous session. One of the last topics we covered was how to add colour to a plot. This can make the plot more appealing, but also help with data interpretation. In this case, we can use different colours to indicate countries belonging to different continents. For example, we can see a cluster of Asia data points with unusually large GDP. At some point we might want to adjust the scale on the x-axis to make the trend between the two axes easier to visualise.

```{r}

ggplot(gapminder, aes(x = gdpPercap, y=lifeExp,col=continent)) + geom_point()
```

The shape and size of points can also be mapped from the data. However, it is easy to get carried away!

```{r}
ggplot(gapminder, aes(x = gdpPercap, y=lifeExp,shape=continent,size=pop)) + geom_point()
```

Scales and their legends have so far been handled using `ggplot2` defaults. `ggplot2` offers functionality to have finer control over scales and legends using the scale methods.

Scale methods are divided into functions by combinations of

-   the aesthetics they control.

-   the type of data mapped to scale.

`scale_`*aesthetic*\_*type*

Try typing in `scale_` then tab to autocomplete. This will provide some examples of the scale functions available in `ggplot2`.

Although different scale functions accept some variety in their arguments, common arguments to scale functions include -

-   name - The axis or legend title

-   limits - Minimum and maximum of the scale

-   breaks - Label/tick positions along an axis

-   labels - Label names at each break

-   values - the set of aesthetic values to map data values

We can choose specific colour palettes, such as those provided by the `RColorBrewer` package. This package is included with R (so you don't need to install it) and provides palettes for different types of scale (sequential, diverging, qualitative).

```{r}
library(RColorBrewer)
display.brewer.all(colorblindFriendly = TRUE)
```

::: callout-important
When creating a plot, always check that the colour scheme is appropriate for people with various forms of colour-blindness
:::

When experimenting with colour palettes and labels, it is useful to save the plot as an object. This saves quite a bit of typing! Notice how nothing get shown on the screen.

```{r}
p <- ggplot(gapminder, aes(x = gdpPercap, y=lifeExp,col=continent)) + geom_point()
```

Running the line of code with just `p` now shows the plot on the screen

```{r}
p 
```

But we can also make modifications to the plot with the `+` symbol. Here, we change the colours to those defined as `Set2` in `RColorBrewer`.

```{r}
## Here we pick 6 colours from the palette
p + scale_color_manual(values=brewer.pal(6,"Set2"))
```

Various labels can be modified using the `labs` function.

```{r}
p + labs(x="Wealth",y="Life Expectancy",title="Relationship between Wealth and Life Expectancy")
```

We can also modify the x- and y- limits of the plot so that any outliers are not shown. `ggplot2` will give a warning that some points are excluded.

```{r}
p + xlim(0,60000)
```

Saving is supported by the `ggsave` function and automatically saves the last plot that was displayed in RStudio. A variety of file formats are supported (`.png`, `.pdf`, `.tiff`, etc) and the format used is determined from the extension given in the `file` argument. The height, width and resolution can also be configured. See the help on `ggsave` (`?ggsave`) for more information.

```{r}
ggsave(file="my_ggplot.png")
```

Most aspects of the plot can be modified from the background colour to the grid sizes and font. Several pre-defined "themes" exist and we can modify the appearance of the whole plot using a `theme_..` function.

```{r}
p + theme_bw()
```

More themes are supported by the `ggthemes` package. You can make your plots look like the Economist, Wall Street Journal or Excel (**but please don't do this!**)

```{r}
## this will check if ggthemes is already installed, and will only install if it is not found

if(!require("ggthemes")) install.packages("ggthemes")
library(ggthemes)
p + theme_excel()
```

## Exercise

::: exercise
Use a boxplot to compare the life expectancy values of Australia and New Zealand. Use a `Set2` palette from `RColorBrewer` to colour the boxplots and apply a "minimal" theme to the plot.
:::

![](/files/training/r/oceania_le_boxplot.png)

::: {.callout-tip collapse="true"}

## Solution

```{r eval=FALSE}
gapminder %>% 
  filter(continent == "Oceania") %>% 
  ggplot(aes(x = country, y = lifeExp,fill=country)) + geom_boxplot() + scale_fill_manual(values=brewer.pal(2,"Set2")) + theme_bw()
```
:::

Another transformation that is useful in this case is to display the x-axis on a log$_10$ scale. This compresses the values on the x-axis (reducing the impact of the high outliers) and makes trends easier to spot

```{r}
p + scale_x_log10()
```

It now seems that `lifeExp` is increasing in a roughly linear fashion with the GDP (on a log$_10$ scale).

::: {.callout-note collapse="true"}
## About the log transformation

The logarithm of 10 (log10) is the exponent to which the base 10 must be "raised" to obtain the number 10. For example, log10(10) = 1, as 10 raised to the power of 1 equals 10.

```{r}
log10(10)
10^1
log10(100)
10^2
```

This transformation helps in simplifying visualisation involving large numbers. The range of our `gdpPercap` values is extremely large. `summary` is a quick way to get various summary statistics from our data

```{r}
## we will use the $ notation for now

summary(gapminder$gdpPercap)
```

After a `log10` transformation the data are much more compressed.

```{r}
summary(log10(gapminder$gdpPercap))
```

The largest value after the log$_10$ transformation is around 5

```{r}
10^5.055
```
:::

## Facets

One very useful feature of `ggplot2` is faceting. This allows you to produce plots for subsets and groupings in your data (aka "facets"). In the scatter plot above, it was quite difficult to determine if the relationship between gdp and life expectancy was the same for each continent. To overcome this, we would like a see a separate plot for each continent.

In we attempted such a task manually we might start off by plotting Africa

```{r}
afr_plot<- gapminder %>% 
  filter(continent == "Africa") %>% 
  ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point() + scale_x_log10()
afr_plot
```

And then the same for Americas:-

```{r}
amr_plot <- gapminder %>% 
  filter(continent == "Americas") %>% 
  ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point() + scale_x_log10()
amr_plot
```

At some point we will have to stitch the plots together (which **is** possible, but we will cover this later) and make sure we have equivalent scales for all plots. In this setup we are manually specifying the name of the continent, which is prone to error. Again, we *could* use something like a *for loop* to make the plots for each continent. However, we aren't covering such techniques in these materials as `dplyr` and `ggplot2` don't tend to require them.

As we said before, `dplyr`, and `ggplot2` are built with the analyst in mind and have many useful features for automating some common tasks. To achieve the plot we want is surprisingly simple. To "facet" our data into multiple plots we can use the `facet_wrap` (1 variable) or `facet_grid` (2 variables) functions and specify the variable(s) we split by.

```{r}
p + facet_wrap(~continent) + scale_x_log10() + xlab("GDP (log10)") + ylab("Life Expectancy")
```

The `facet_grid` function will create a grid-like plot with one variable on the x-axis and another on the y-axis.

```{r fig.width=12}
p + facet_grid(continent~year)
```

The previous plot was a bit messy as it contained all combinations of year and continent. Let's suppose we want our analysis to be a bit more focused and disregard countries in Oceania (as there are only 2 in our dataset) and maybe years between 1997 and 2002. However, we can only "add" more information from our plots and not take anything away. Therefore the suggested approach is to pre-filter and manipulate the data into the form you want for plotting.

Weknow how to restrict the rows from the `gapminder` dataset using the `filter` function. Instead of filtering the data, creating a new data frame, and constructing the data frame from these new data we can use the`%>%` operator to create the data frame "on the fly" and pass directly to `ggplot`. Thus we don't have to save a new data frame or alter the original data.

```{r fig.width=12}
filter(gapminder, continent!="Oceania", year %in% c(1997,2002,2007)) %>% 
  ggplot(aes(x = gdpPercap, y=lifeExp,col=continent)) + geom_point() + facet_grid(continent~year)
```

There is lots more to cover on `ggplot2` and quickly we can start to understand our data without *too much* in the way of coding. When it comes to reporting and justifying our findings we will need to produce some numerical summaries. We tackle this in the next section.

# Summarising and grouping with dplyr

We now revisit one of the tasks from the end pf Part 1, but in the context of `dplyr`. Suppose we want to calculate a summary statistic (average, standard deviation, etc) from the columns in our data frame. Previously we saw the "base R" way of doing this

```{r}
mean(gapminder$gdpPercap)
```

However, you can only specify one column name after the `$` and the `mean` is calculated on the entire data frame. For a dataset such as this we probably want summaries for particular subsets e.g. different years, continents etc. We will build up to this and consider the simplest case first.

The `summarise` function can take any R function that takes a vector of values (i.e. a column from a data frame) and returns a single value. Some of the more useful functions include:

-   `min` minimum value
-   `max` maximum value
-   `sum` sum of values
-   `mean` mean value
-   `sd` standard deviation
-   `median` median value
-   `IQR` the interquartile range
-   `n_distinct` the number of distinct values
-   `n` the number of observations (Note: this is a special function that doesn't take a vector argument, i.e. column)

To calculate several statisitcs in one go we can use:-

```{r}
library(dplyr)
summarise(gapminder, min(lifeExp), max(gdpPercap), mean(pop))
```

It is also possible to summarise using a function that takes more than one value, i.e. from multiple columns. For example, we could compute the correlation between year and life expectancy. Here we also assign names to the table that is produced.

```{r}
gapminder %>% 
summarise(MinLifeExpectancy = min(lifeExp), 
          MaximumGDP = max(gdpPercap), 
          AveragePop = mean(pop), 
          Correlation = cor(year, lifeExp))
```

Notice that the correlation is not that impressive. However, it is not particularly useful to calculate such values from the entire table as we have different continents and years. The correlation would make a lot more sense on a per-country basis. It *would* be possible to achieve summaries for each continent manually with some effort.

```{r}
gapminder %>% 
  filter(continent == "Africa") %>% 
  summarise(MinLifeExpectancy = min(lifeExp), 
          MaximumGDP = max(gdpPercap), 
          AveragePop = mean(pop))
```

However, as for the facet plot example above we have to repeat for each continent. Tedious and could cause errors.

Instead, the `group_by` function allows us to split the table into different categories, and compute summary statistics for each year (for example).

```{r}
gapminder %>% 
    group_by(year) %>% 
    summarise(MinLifeExpectancy = min(lifeExp), 
              MaximumGDP = max(gdpPercap), 
              AveragePop = mean(pop))
```

More than one categorical variable can be used for finer-grain summaries. Here the summaries are for each year and continent combination

```{r}
gapminder %>% 
    group_by(year,continent) %>% 
    summarise(MinLifeExpectancy = min(lifeExp), 
              MaximumGDP = max(gdpPercap), 
              AveragePop = mean(pop))
```

We can list as many summary functions as we like. Whilst this can make our code somewhat verbose there are many helper functions available. Consider an example where we want to average all the columns in our data:-

```{r}
gapminder %>% 
    group_by(year) %>% 
    summarise(MeanLifeExpectancy = mean(lifeExp), 
              MeanGDP = mean(gdpPercap), 
              MeanPop = mean(pop))
```

This wasn't a huge effort to write this code. However, it would be much more tedious for a dataset with many more columns. Recognising this, we can use the convenient `summarise_all` function. This will return `NA` values for columns that do not contain numeric values.

```{r warning=FALSE,message=FALSE}
gapminder %>% 
  group_by(continent) %>% 
  summarise_all(mean)
```

The nice thing about `summarise` is that it can followed up by any of the other `dplyr` verbs that we have met so far (`select`, `filter`, `arrange`..etc). As the `country` column of the previous output containing missing values we can exclude it from further processing.

```{r warning=FALSE,message=FALSE}
gapminder %>% 
  group_by(continent) %>% 
  summarise_all(mean) %>% 
  select(-country)
```

Returning to the correlation between life expectancy and year, we use the `group_by` technique as follows:-

```{r,message=FALSE}
gapminder %>%     
    group_by(country) %>% 
    summarise(Correlation = cor(year , lifeExp))
```

We can then arrange the table by the correlation to see which countries have the lowest correlation

```{r,message=FALSE}
gapminder %>%      
    group_by(country) %>% 
    summarise(Correlation = cor(year , lifeExp)) %>% 
    arrange(Correlation)
```

We can filter the results to find observations of interest

```{r,message=FALSE}
gapminder %>%      
    group_by(country) %>% 
    summarise(Correlation = cor(year , lifeExp)) %>% 
    filter(Correlation < 0)
```

The countries we identify could then be used as the basis for a plot.

```{r}
library(ggplot2)
filter(gapminder, country %in% c("Rwanda","Zambia","Zimbabwe")) %>% 
  ggplot(aes(x=year, y=lifeExp,col=country)) + geom_line()
```

------------------------------------------------------------------------

------------------------------------------------------------------------

------------------------------------------------------------------------

It is perhaps worth considering at this point how sophisticated our R programming has become. Suppose we had been tasked with discovering countries whose correlation between life expectancy and time is negative. At the beginning of Part 1 you may have considered such a task to be extremely complicated. However, we can achieve this in just four lines of code - and that includes the code to read the data into R 🎉

```{r}
read_csv("raw_data/gapminder.csv") %>%      
    group_by(country) %>% 
    summarise(Correlation = cor(year , lifeExp)) %>% 
    filter(Correlation < 0)
```

### Exercise

::: exercise
-   Summarise the `gapminder` data in an appropriate manner to produce a plot to show the change in average `gdpPercap` for each continent over time.
-   see below for a suggestion
    -   HINT: you will need to use the `geom_col` function to create the bar plot
:::

------------------------------------------------------------------------

------------------------------------------------------------------------

------------------------------------------------------------------------

![](/files/training/r/summarise_example.png)

::: {.callout-tip collapse="true"}
## Solution

```{r eval=FALSE}
group_by(gapminder, continent, year) %>% 
  summarise(GDP = mean(gdpPercap)) %>% 
  ggplot(aes(x = year, y = GDP, fill=continent)) + geom_col() + facet_wrap(~continent)
```
:::

# Joining

In many real life situations, data are spread across multiple tables or spreadsheets. Usually this occurs because different types of information about a subject, e.g. a patient, are collected from different sources. It may be desirable for some analyses to combine data from two or more tables into a single data frame based on a common column, for example, an attribute that uniquely identifies the subject.

`dplyr` provides a set of join functions for combining two data frames based on matches within specified columns. For those familiar with such SQL, these operations are very similar to carrying out join operations between tables in a relational database.

As a toy example, lets consider two data frames that some results of testing whether genes A, B and C are significant in our study (gene expression, mutations, etc.)

```{r}
gene_results <- data.frame(Name=LETTERS[1:3], pvalue = c(0.001, 0.1,0.01))
gene_results
```

We might also have a data frame containing more data about the genes; such as which chromosome they are located on. As part of our data interpretation we might need to know where in the genome the genes are located. Note that both data frames have a column called `Name`. This column will be used to identify genes common to both tables.

```{r}
gene_anno <- data.frame(Name = c("A","B","D"), chromosome=c(1,1,3))
gene_anno
```

There are various ways in which we can join these two tables together. We will first consider the case of a "left join".

![](https://raw.githubusercontent.com/sheffield-bioinformatics-core/r-crash-course/master/images/left-join.gif)

*Animated gif by Garrick Aden-Buie*

`left_join` returns all rows from the first data frame regardless of whether there is a match in the second data frame. Rows with no match are included in the resulting data frame but have `NA` values in the additional columns coming from the second data frame.

Animations to illustrate other types of join are available at <https://github.com/gadenbuie/tidy-animated-verbs>

```{r}
left_join(gene_results, gene_anno)
```

`right_join` is similar but returns all rows from the second data frame that have a match with rows in the first data frame based on the specified column.

```{r}
right_join(gene_results, gene_anno)
```

`inner_join` only returns those rows where matches could be made

```{r}
inner_join(gene_results, gene_anno)
```

------------------------------------------------------------------------

------------------------------------------------------------------------

------------------------------------------------------------------------

# Wrap-up

We have introduced a few of the essential packages from the R tidyverse that can help with data manipulation and visualisation.

![](https://aberdeenstudygroup.github.io/studyGroup/lessons/SG-T2-JointWorkshop/tidyverse.png) Hopefully you will feel more confident about importing your data into R and producing some useful visualisations. You will probably have questions regarding the analysis of your own data. Some good starting points to get help are listed below.

::: information
-   [tidyverse homepage](https://www.tidyverse.org/)
-   [R graph gallery](https://www.r-graph-gallery.com/)
:::

To finish the workshop we will look at the analysis of some relevant data that we can import into R and analyse with the tools from the workshop.

## Data Cleaning: A COVID-19 data example

Data for global COVID-19 cases are available online from CSSE at Johns Hopkins University on their github repository.

::: {.callout-note}
[github](www.github.com) is an excellent way of making your code and analysis available for others to reuse and share. Private repositories with restricted access are also available. Here is a useful beginners guide.

\-[Friendly github intro](https://kirstiejane.github.io/friendly-github-intro/)
:::

R is capable of downloading files to our own machine so we can analyse them. We need to know the URL (for the COVID data we can find this from github, or use the address below) and can specify what to call the file when it is downloaded.

```{r}
if(!file.exists("raw_data/time_series_covid19_confirmed_global.csv")){
  download.file("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv",destfile = "raw_data/time_series_covid19_confirmed_global.csv")
}
```

We can use the `read_csv` function as before to import the data and take a look. We can see the basic structure of the data is one row for each country / region and columns for cases on each day.

```{r}
covid <- read_csv("raw_data/time_series_covid19_confirmed_global.csv")
covid
```



Much of the analysis of this dataset has looked at trends over time (e.g. increasing /decreasing case numbers, comparing trajectories). As we know by now, the `ggplot2` package allows us to map columns (variables) in our dataset to aspects of the plot.

In other words, we would expect to create plots by writing code such as:-

```         
ggplot(covid, aes(x = Date, y =...)) + ...
```

Unfortunately such plots are not possible with the data in it's current format. Counts for each date are containing in a different column. What we require is a column to indicate the date, and the corresponding count in the next column. Such data arrangements are known as *long data*; whereas we have *wide* data. Fortunately we can convert between the two using the `tidyr` package (also part of tidyverse).

```{r eval=FALSE}
## install tidyr if you don't already have it
install.packages("tidyr")
```

::: {.callout-note}

## About "tidy data"

For more information on *tidy data*, and how to convert between long and wide data, see

<https://r4ds.had.co.nz/tidy-data.html>
:::

For convenience we will also rename the column containing country names

```{r}
## set the show_col_types argument to FALSE to suppress message about column types

library(tidyr)
covid <- read_csv("raw_data/time_series_covid19_confirmed_global.csv",show_col_types = FALSE) %>% 
    rename(country = `Country/Region`) %>% 
  pivot_longer(5:last_col(),names_to="Date", values_to="Cases")
covid
```

The number of rows and columns has changed dramatically, but this is a much more usable form for `dplyr` and `ggplot2`.

Another point to note is that the dates are not in an internationally recognised format, which could cause a problem for some visualisations that rely on date order.

![](http://images3.memedroid.com/images/UPLOADED951/62d545f80a3d6.jpeg)

 We can fix by explicitly converting to YYYY-MM-DD format. The `as.Date` function can be used to convert an existing column into standardised dates. It needs to know how the months, days and years are being specified which might look a bit obtuse. The specification needed for these data is `%m/%d/%y`. This means months(`%m`) separated by a  `/` followed by a day (`%d`) followed by another `/` followed by the year represented by two digits (`%y`). Other conversions are possible including if you have dates with month names (`Jan`, `Feb`...) or four digit years. See the link below for more information.



::: {.callout-tip}

## Dealing with dates

See this website for more about representing and converting dates in R.

- [https://www.statology.org/r-date-format/](https://www.statology.org/r-date-format/)

For more ways of dealing with dates in R see the `lubridate` package which can handle tasks such as calculating intervals between dates and much more

:::

```{r}
covid <- read_csv("raw_data/time_series_covid19_confirmed_global.csv",show_col_types = FALSE) %>% 
    rename(country = `Country/Region`) %>% 
  pivot_longer(5:last_col(),names_to="Date", values_to="Cases") %>% 
  mutate(Date=as.Date(Date,"%m/%d/%y"))
covid
```

Another useful modification is to make sure only one row exists for each country. If we look at the data for some countries (e.g. China and UK) there are different entries for provinces and oversees territories. So we can change the Cases to be the `sum` of all cases for that country on a particular day. We can do this using the `group_by` and `summarise` functions from above.



```{r}
covid <- read_csv("raw_data/time_series_covid19_confirmed_global.csv", show_col_types = FALSE) %>% 
  rename(country = `Country/Region`) %>% 
  pivot_longer(5:last_col(),names_to="Date", values_to="Cases") %>% 
  mutate(Date=as.Date(Date,"%m/%d/%y")) %>% 
  group_by(country,Date) %>% 
  summarise(Cases = sum(Cases))

covid
```

```{r}
covid
```

Since we previously renamed the country column in `covid` and both data frames now have a column called `country` we can use a `left_join`. 

```{r}
left_join(gapminder, covid)
```

::: {callout-tip}

If we hadn't used `rename` previously, the joining code would look like this

```{r eval=FALSE}
left_join(gapminder, covid, by = c("county" = "Country/Region"))
```


:::

Furthermore, we might also want to just use the `2007` rows from `gapminder`. 

```{r}
filter(gapminder, year == 2007) %>% 
  left_join(covid)
```


### Exercise

::: exercise
What plots and summaries can you make from these data?

-   Plotting the number of cases over time for certain countries
-   Which country in each continent currently has the highest number of cases?
-   Normalise the number of cases for population size (using 2007 population figures as a population estimate)?
    -   e.g. cases per 100,000
-   Which European countries have the highest number of cases per 100,000 population
    -   e.g. <https://www.statista.com/statistics/1110187/coronavirus-incidence-europe-by-country/>
:::

```{r}

 
```

::: {.callout-tip collapse="true"}

## Some solutions


Compare trajectories of different countries. The `%in%` operator is an alternative to or (`|`) to find a country name that can have a number of possibilities.


```{r}
covid <- read_csv("raw_data/time_series_covid19_confirmed_global.csv") %>% 
  rename(country = `Country/Region`) %>% 
  pivot_longer(5:last_col(),names_to="Date", values_to="Cases") %>% 
  mutate(Date=as.Date(Date,"%m/%d/%y")) %>% 
  group_by(country,Date) %>% 
  summarise(Cases = sum(Cases))


filter(covid, country %in% c("United Kingdom","France","Spain")) %>%
  ggplot(aes(x = Date, y = Cases,col=country)) + geom_line()
```

To explore the european data on a particular date, we first filter gapminder appropriately

```{r}
filter(gapminder, year == 2007,continent=="Europe") %>%
  left_join(covid) %>% 
  filter(Date == "2023-01-13") %>% 
  mutate(Cases = round(Cases / (pop / 1e5)))
```

Try to make example similar to [https://www.statista.com/statistics/1110187/coronavirus-incidence-europe-by-country/](https://www.statista.com/statistics/1110187/coronavirus-incidence-europe-by-country/). We're not using up-to-date figures for population so there will be some differences. The two data frames can be joined because they have a column name in common (`country`). Most of the country names that appear in `gapminder` also appear in the `covid` dataset, so not much data is lost in the join. 

Since we are interested in European countries for this dataset, we pre-filter the `gapminder` data. Also, we only need the population values from 2007.


```{r}
filter(gapminder, year == 2007,continent=="Europe") %>% 
  left_join(covid) %>% 
  filter(Date == "2022-01-06") %>% 
  mutate(Cases = round(Cases / (pop / 1e5))) %>% 
  ggplot(aes(x = Cases, y = country)) + geom_col()
```


The default ordering for the bars is alphabetical, which is probably not a natural choice. The `forcats` package, which is part of `tidyverse` allows *factors* in a data frame to be re-ordered and re-labeled.

- [forcats package](https://forcats.tidyverse.org/)

In particular, we can use the `fct_reorder` function to reorder the country names according to the number of cases. This can be done inside the `ggplot2` function itself.

```{r}
## this will install the package if it is not already installed
if(!require(forcats)) install.packages(forcats)

filter(gapminder, year == 2007,continent=="Europe") %>% 
  left_join(covid) %>% 
  filter(Date == "2023-01-13") %>% 
  mutate(Cases = round(Cases / (pop / 1e5))) %>% 
  ggplot(aes(x = Cases, y = forcats::fct_reorder(country,Cases))) + geom_col()

```

A heatmap of number of cases over time (similar to that reported by the BBC) can be achieved using a `geom_tile`

```{r}
### Get the 2007 gapminder data to avoid repeating data
filter(gapminder, year ==  2007, continent=="Europe") %>% 
  left_join(covid) %>% 
  filter(!is.na(Cases)) %>% ## remove countries with missing values%>% 
  mutate(Cases = round(Cases / (pop / 1e5))) %>% 
  ggplot(aes(x = Date, y = country,fill=Cases)) + geom_tile() + scale_fill_viridis_c()
  
```

:::
